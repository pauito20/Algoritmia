Index: Entregables/Entregable3/entregable3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\nimport sys\nfrom typing import *\n\nfrom typing import Tuple\n\nfrom Teoría.bt_scheme import PartialSolutionWithVisitedControl, Solution, BacktrackingVCSolver, State\n\nPos = Tuple[int, int]\n\n\ndef puzleSolver(matrizMapa , player_pos : Tuple[int, ...], boxes_start : List[Tuple[int, int]], boxes_end : List[Tuple[int, int]], maximoMovimientos : int ):\n    class puzlePS(PartialSolutionWithVisitedControl):\n        def __init__(self, decisiones: Tuple[str,...], posActualPlayer: Tuple[int, ...], posActualBoxes : List[Tuple[int, int]] ):\n            self.decisiones = decisiones\n            self.posActualPlayer = posActualPlayer\n            self.posActualBoxes = posActualBoxes\n            self.n = len(decisiones)\n\n\n            print(\"Decisiones: \", self.decisiones)\n            print(\"Posición Actual: \", self.posActualPlayer)\n            print(\"Posición Actual Caja: \", self.posActualBoxes)\n            print(\"Numero decisiones: \", self.n)\n            print(\"- - - - - - - - - - - - - - -\")\n\n\n\n        def is_solution(self) -> bool:\n            return self.n <= maximoMovimientos and self.posActualBoxes == boxes_end\n\n        def get_solution(self) -> Solution:\n            return self.decisiones\n\n        def successors(self) -> Iterable[\"puzlePS_lista\"]:\n\n            if self.n < maximoMovimientos:\n                #ARRIBA\n                upPos = (self.posActualPlayer[0] - 1, self.posActualPlayer[1])\n                if self.posActualBoxes.__contains__(upPos):\n                    upBox = (upPos[0] - 1, upPos[1])\n                    if matrizMapa[int(upBox[0])][int(upBox[1])] != \"#\" and not self.posActualBoxes.__contains__(upBox):\n                        self.posActualBoxes.remove(upPos)\n                        self.posActualBoxes.append(upBox)\n                        yield puzlePS(self.decisiones + (\"U\",), upPos, self.posActualBoxes)\n                else:\n                    if matrizMapa[int(upPos[0])][int(upPos[1])] != \"#\":\n                        yield puzlePS(self.decisiones + (\"U\",), upPos, self.posActualBoxes)\n\n                # ABAJO\n                downPos = (self.posActualPlayer[0] + 1, self.posActualPlayer[1])\n                if self.posActualBoxes.__contains__(downPos):\n                    downBox = (downPos[0] + 1, downPos[1])\n                    if matrizMapa[int(downBox[0])][int(downBox[1])] != \"#\" and not self.posActualBoxes.__contains__(\n                            downBox):\n                        self.posActualBoxes.remove(downPos)\n                        self.posActualBoxes.append(downBox)\n                        yield puzlePS(self.decisiones + (\"D\",), downPos, self.posActualBoxes)\n                else:\n                    if matrizMapa[int(downPos[0])][int(downPos[1])] != \"#\":\n                        yield puzlePS(self.decisiones + (\"D\",), downPos, self.posActualBoxes)\n                # DERECHA\n                rightPos = (self.posActualPlayer[0], self.posActualPlayer[1] + 1)\n                if self.posActualBoxes.__contains__(rightPos):\n                    rightBox = (rightPos[0], rightPos[1] + 1)\n                    if matrizMapa[int(rightBox[0])][\n                        int(rightBox[1])] != \"#\" and not self.posActualBoxes.__contains__(rightBox):\n                        self.posActualBoxes.remove(rightPos)\n                        self.posActualBoxes.append(rightBox)\n                        yield puzlePS(self.decisiones + (\"R\",), rightPos, self.posActualBoxes)\n                else:\n                    if matrizMapa[int(rightPos[0])][int(rightPos[1])] != \"#\":\n                        yield puzlePS(self.decisiones + (\"R\",), rightPos, self.posActualBoxes)\n\n                #IZQUIERDA\n                leftPos = (self.posActualPlayer[0], self.posActualPlayer[1] - 1)\n                if self.posActualBoxes.__contains__(leftPos):\n                    leftBox = (leftPos[0], leftPos[1]-1)\n                    if matrizMapa[int(leftBox[0])][int(leftBox[1])] != \"#\" and not self.posActualBoxes.__contains__(leftBox):\n                        self.posActualBoxes.remove(leftPos)\n                        self.posActualBoxes.append(leftBox)\n                        yield puzlePS(self.decisiones + (\"L\",), leftPos, self.posActualBoxes)\n                else:\n                    if matrizMapa[int(leftPos[0])][int(leftPos[1])] != \"#\":\n                        yield puzlePS(self.decisiones + (\"L\",), leftPos, self.posActualBoxes)\n\n\n\n\n\n\n\n        def state(self) -> State:  \n           return(self.posActualPlayer, tuple(self.posActualBoxes))\n       \n        def f(self) -> Union[int, float]:   #Es la funcion que queremos optimizar\n            return self.n\n\n\n\n\n    initial_ps = puzlePS((), player_pos, boxes_start)\n    return BacktrackingVCSolver.solve(initial_ps)\n\ndef contruyeMatriz(levelMap):\n    m = []\n    for i in range(len(level_map)):\n        fila = []\n        for c in str(level_map[i]):\n            fila.append(c)\n        m.append(fila)\n    return m\n\ndef read_level(puzle_lines: List[str]) -> Tuple[List[str], Pos, List[Pos], List[Pos]]:\n\n    # Averigua la posición del jugador y las posiciones iniciales y finales de las cajas\n    player_pos, boxes_start, boxes_end = None, [], []\n    num_rows = len(puzle_lines)\n    num_cols = len(puzle_lines[0].strip())\n\n    for r in range(num_rows):\n        for c in range(num_cols):\n            if puzle_lines[r][c] == 'p':\n                player_pos = (r, c)\n            elif puzle_lines[r][c] == 'o':\n                boxes_start.append((r, c))\n            elif puzle_lines[r][c] == 'x':\n                boxes_end.append((r, c))\n\n    # Crea un mapa (incluye únicamente paredes y pasillos, borra 'p','x' y 'o'):\n    tr = str.maketrans(\"pxo\", \"   \")\n    level_map = []\n    for l in puzle_lines:\n        level_map.append(l.strip().translate(tr))\n\n    return  level_map, player_pos, boxes_start, boxes_end\n\n\n\n\nif __name__ == '__main__':\n\n\n    numMaxMovimientos = int ( input(\"Introduce el numero maximo de movimientos: \") )\n    name_fich = input(\"Introduce el nombre(ruta) del fichero: \")\n\n    if not os.path.isfile(name_fich):\n        print(\"El parametro introducido(\", name_fich, \") no es un fichero.\")\n        exit(0)\n\n\n    file = open(name_fich, \"r\")\n    puzle = []\n    linea = str(file.readline())\n\n    while linea != \"\":\n        puzle.append(linea)\n        linea = str(file.readline())\n\n    '''\n    #Creamos un entero para almacenar el numero maximos de movimientos\n    numMaxMovimientos = int(sys.argv[1])\n\n    #Convertimos el fichero en una lista de líneas\n    puzle = sys.stdin.readlines()\n    '''\n\n    level_map, player_pos, boxes_start, boxes_end = read_level(puzle)\n\n    res = ()\n\n    matrizMapa = contruyeMatriz(level_map)\n\n\n\n    for sol in puzleSolver( matrizMapa , player_pos , boxes_start , boxes_end, numMaxMovimientos):\n        print(sol)\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Entregables/Entregable3/entregable3.py	(revision 8613f3b79d1d7f5a8e57b51f2652d2378254a4e3)
+++ Entregables/Entregable3/entregable3.py	(date 1606841805960)
@@ -9,9 +9,9 @@
 Pos = Tuple[int, int]
 
 
-def puzleSolver(matrizMapa , player_pos : Tuple[int, ...], boxes_start : List[Tuple[int, int]], boxes_end : List[Tuple[int, int]], maximoMovimientos : int ):
+def puzleSolver(matrizMapa , player_pos : Tuple[int, ...], boxes_start: List[Tuple[int, int]], boxes_end: List[Tuple[int, int]], maximoMovimientos : int ):
     class puzlePS(PartialSolutionWithVisitedControl):
-        def __init__(self, decisiones: Tuple[str,...], posActualPlayer: Tuple[int, ...], posActualBoxes : List[Tuple[int, int]] ):
+        def __init__(self, decisiones: Tuple[str, ...], posActualPlayer: Tuple[int, ...], posActualBoxes: List[Tuple[int, int]] ):
             self.decisiones = decisiones
             self.posActualPlayer = posActualPlayer
             self.posActualBoxes = posActualBoxes
@@ -26,8 +26,9 @@
 
 
 
+
         def is_solution(self) -> bool:
-            return self.n <= maximoMovimientos and self.posActualBoxes == boxes_end
+            return self.n < maximoMovimientos and self.posActualBoxes == boxes_end
 
         def get_solution(self) -> Solution:
             return self.decisiones
@@ -35,6 +36,20 @@
         def successors(self) -> Iterable["puzlePS_lista"]:
 
             if self.n < maximoMovimientos:
+
+                # IZQUIERDA
+                leftPos = (self.posActualPlayer[0], self.posActualPlayer[1] - 1)
+                if self.posActualBoxes.__contains__(leftPos):
+                    leftBox = (leftPos[0], leftPos[1] - 1)
+                    if matrizMapa[int(leftBox[0])][int(leftBox[1])] != "#" and not self.posActualBoxes.__contains__(
+                            leftBox):
+                        self.posActualBoxes.remove(leftPos)
+                        self.posActualBoxes.append(leftBox)
+                        yield puzlePS(self.decisiones + ("L",), leftPos, self.posActualBoxes)
+                else:
+                    if matrizMapa[int(leftPos[0])][int(leftPos[1])] != "#":
+                        yield puzlePS(self.decisiones + ("L",), leftPos, self.posActualBoxes)
+
                 #ARRIBA
                 upPos = (self.posActualPlayer[0] - 1, self.posActualPlayer[1])
                 if self.posActualBoxes.__contains__(upPos):
@@ -72,17 +87,7 @@
                     if matrizMapa[int(rightPos[0])][int(rightPos[1])] != "#":
                         yield puzlePS(self.decisiones + ("R",), rightPos, self.posActualBoxes)
 
-                #IZQUIERDA
-                leftPos = (self.posActualPlayer[0], self.posActualPlayer[1] - 1)
-                if self.posActualBoxes.__contains__(leftPos):
-                    leftBox = (leftPos[0], leftPos[1]-1)
-                    if matrizMapa[int(leftBox[0])][int(leftBox[1])] != "#" and not self.posActualBoxes.__contains__(leftBox):
-                        self.posActualBoxes.remove(leftPos)
-                        self.posActualBoxes.append(leftBox)
-                        yield puzlePS(self.decisiones + ("L",), leftPos, self.posActualBoxes)
-                else:
-                    if matrizMapa[int(leftPos[0])][int(leftPos[1])] != "#":
-                        yield puzlePS(self.decisiones + ("L",), leftPos, self.posActualBoxes)
+
 
 
 
Index: Practicas/Problemas/Practica5Pau/divide_y_vencerasPau.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Practicas/Problemas/Practica5Pau/divide_y_vencerasPau.py	(date 1606840530500)
+++ Practicas/Problemas/Practica5Pau/divide_y_vencerasPau.py	(date 1606840530500)
@@ -0,0 +1,25 @@
+from typing import *
+
+
+def punto_fijo(v: List[int]) -> Optional[int]:
+    def punto_fijo_(i: int, j: int) -> Optional[int]:
+        #Buscará el punto fijo desde la posición "i" hasta la "j" donde "i" esta incluido y "j" no
+        m = (i+j) // 2
+        if i == j:
+            return None
+        if v[m] == m:
+            return m
+        elif v[m] > m:
+            return punto_fijo_(i, m)
+        return punto_fijo_(m+1, j)
+
+
+
+    #Busco en tot el vector, pero al tener dos parametros "i" i "j" no hay coste
+    #En caso de usar listas, el coste aumentaria en memoria ya que se debería almacenar espacio para ello
+    return punto_fijo_(0, len(v))
+
+
+if __name__ == "__main__":
+    print(punto_fijo([-10, -5, 1, 3, 6]))
+    print(punto_fijo([-10, -5, 1, 2, 6]))
